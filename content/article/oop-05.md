---
title: OOP 课程笔记 Week 05 创建和销毁
date: 2021-3-22
tags: 
- OOP
mathjax: true
cover: https://z3.ax1x.com/2021/06/07/204701.png
---



## Week 05 创建和销毁

### 5.0 Overview

+ 5.1 友元
+ 5.2 静态成员与常量成员
+ 5.3 常量/静态/参数对象的构造与析构时机
+ 5.4 对象的new和delete

### 5.1 友元

+ 友元
  + 被声明为友元的函数或类，具有对出现友元声明的类的private及protected成员的访问权限，即可以访问该类的一切成员。
  + 友元的声明只能在类内进行。

+ 可以声明别的类的成员函数，包括构造和析构函数，为当前类的友元。
+ 友元的声明与当前所在域是否为private或public无关。

### 5.2 静态成员与常量成员

#### 5.2.1 static

1. 静态变量与静态函数

+ 静态变量：使用static修饰的变量
  + 初始化：初次定义时需要初始化，且只能初始化一次。
  + 静态局部变量存储在静态存储区，生命周期将持续到整个程序结束
  + 静态全局变量是**内部可链接**的，作用域仅限其声明的文件，不能被其他文件所用，可以避免和其他文件中的同名变量冲突
+ 静态函数：使用static修饰的函数
  + 静态函数是**内部可链接**的，作用域仅限其声明的文件，不能被其他文件所用，可以避免和其他文件中的同名函数冲突

2. 静态数据成员与静态成员函数

+ 静态数据成员：使用static修饰的数据成员，是隶属于类的，称为类的静态数据成员，也称“类变量”
  + 静态数据成员被该类的所有对象共享（即所有对象中的这个数据域处在同一内存位置）
  + 类的静态成员（数据、函数）既可以通过对象来访问，也可以通过类名来访问，如`ClassName::static_var`或者`a.static_var`（a为ClassName类的对象）
  + 类的静态数据成员要在实现文件中赋初值，格式为：`Type ClassName::static_var = Value; `
  + 和全局变量一样，类的静态数据成员在程序开始前初始化

+ 静态成员函数：在返回值前面添加static修饰的成员函数，称为类的静态成员函数
  + 和静态数据成员类似，类的静态成员函数既可以通过对象来访问，也可以通过类名来访问，如`ClassName::static_function`或者`a.static_function`(a为ClassName类的对象）

+ **静态成员函数不能访问非静态成员**。（原因：分配时序）

#### 5.2.2 const

1. 常量

+ 修饰变量时（如`const int n = 1;`），必须就地初始化，该变量的值在其生命周期内都不会发生变化
+ 修饰引用/指针时（如`int a=1; const int& b=a;`），不能通过该引用/指针修改相应变量的值，常用于函数参数以保证函数体中无法修改参数的值
+ 修饰函数返回值时（如`const int* func() {…}`），函数返回值的内容（或其指向的内容）不能被修改

2. 常量数据成员和常量成员函数

+ 常量数据成员：使用const修饰的数据成员，称为类的常量数据成员，在对象的整个生命周期里不可更改
  + 常量数据成员可以在
    + 构造函数的初始化列表中被初始化
    + 就地初始化
    + **不允许**在构造函数的函数体中通过赋值来设置

+ 常量成员函数
  + 成员函数也能用const来修饰，称为常量成员函数。
  + 常量成员函数的访问权限：实现语句不能修改类的数据成员，即不能改变对象状态（内容）
    `ReturnType Func(…) const {…}`
  + 注意区别：`const ReturnType Func(…) {…}`
  + 若对象被定义为常量(`const ClassName a;`)，则它只能调用以const修饰的成员函数
    + 常量对象：对象中的“数据”不能变

3. 常量静态变量

+ 当然，我们可以定义既是常量也是静态的变量
  + 作为类的常量变量
+ 常量静态变量需要在类外进行定义，但有两个例外：int和enum类型可以就地初始化
+ 常量静态变量和静态变量一样，满足访问权限的任意函数均可访问，但都不能修改

```cpp
class foo {
	static const char* cs; // 不可就地初始化
static const int i = 3; // 可以就地初始化
static const int j; // 也可以在类外定义
};

const char* foo::cs = "foo C string";
const int foo::j = 4;
```

### 5.3 常量/静态/参数对象的构造与析构时机

#### 5.3.1 常量对象的构造与析构

+ **常量全局/局部对象**的构造与析构时机和**普通全局/局部对象**相同
+ 常量全局对象：在main()函数调用之前进行初始化，在main()函数执行完return，程序结束时，对象被析构
  常量局部对象：在程序执行到该局部对象的代码时被初始化。在局部对象生命周期结束、即所在作用域结束后被析构

#### 5.3.2 静态对象的构造与析构

1. 静态全局对象

+ 静态全局对象的构造与析构时机和普通全局对象相同

2. 函数中静态对象

+ 函数内部定义的静态局部对象

+ 在程序执行到该静态局部对象的代码时被初始化，离开作用域不析构。
+ 第二次执行到该对象代码时，不再初始化，直接使用上一次的对象。
+ 在main()函数结束后被析构。

3. 类静态对象

+ 类A的对象a作为类B的静态变量
+ a的构造与析构表现和全局对象类似，即在main()函数调用之前进行初始化，在main()函数执行完return，程序结束时，对象被析构
+ 和B是否实例化无关

#### 5.3.3 参数对象的构造和析构

### 5.4 对象的new和delete

